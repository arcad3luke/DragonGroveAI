import os
import sqlite3
import requests
import json
import time
from datetime import datetime
from rich.console import Console

# Console for styled output
console = Console()

# MalwareBazaar API key and URL
MALWARE_BAZAAR_API_KEY = os.environ.get("MALWARE_BAZAAR_API_KEY")  # Use environment variable for security
MALWARE_BAZAAR_API_URL = "https://mb-api.abuse.ch/api/v1/"

# SQLite database file
SAMPLES_DATABASE_FILE = "database/malware_samples.db"

# Chunk size and total samples count
CHUNK_SIZE = 200
TOTAL_SAMPLES = 896735  # Use the actual total count from MalwareBazaar

# Rate-limiting delay in seconds
RATE_LIMIT_DELAY = 2


def initialize_database():
    """
    Initialize SQLite database and create the samples table if it doesn't exist.
    """
    os.makedirs(os.path.dirname(SAMPLES_DATABASE_FILE), exist_ok=True)
    conn = sqlite3.connect(SAMPLES_DATABASE_FILE)
    cursor = conn.cursor()

    # Create the malware_samples table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS malware_samples (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            sha256_hash TEXT UNIQUE,
            metadata TEXT,
            added_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    """)
    conn.commit()
    conn.close()
    console.print("[green]Database initialized successfully.[/green]")


def fetch_recent_samples(selector="200"):
    """
    Fetch recent malware samples from MalwareBazaar.
    :param selector: "time" for last 60 minutes or "100" for the latest 100 additions.
    :return: List of malware sample dictionaries.
    """
    console.print(f"[cyan]Fetching malware samples with selector: {selector}...[/cyan]")

    # Payload with authentication and selector

    for _ in range(2):  # Run two consecutive pulls of 100
    		payload = {
        		"query": "get_recent",
        		"auth_key": MALWARE_BAZAAR_API_KEY,
        		"selector": "100"
    		}
    try:
        # POST request to API
        response = requests.post(MALWARE_BAZAAR_API_URL, data=payload, timeout=30)
        response.raise_for_status()  # Ensure the request was successful
        data = response.json()
        # Process response data
        if data.get("query_status") == "ok" and data.get("data"):
   		    console.print(f"[green]Fetched {len(data['data'])} recent samples.[/green]")
   		    return data["data"]
        else:
            console.print("[yellow]No results found for the given selector.[/yellow]")
            return []
    except requests.exceptions.RequestException as e:
        console.print(f"[red]Network error or API issue: {e}[/red]")
    # Log full metadata for analysis
    console.print(f"[magenta]Full sample metadata: {json.dumps(sample, indent=2)}[/magenta]")

def get_known_hashes():
    """
    Retrieve all known hashes from the database.
    :return: Set of known SHA256 hashes.
    """
    conn = sqlite3.connect(SAMPLES_DATABASE_FILE)
    cursor = conn.cursor()

    # Query all stored hashes
    cursor.execute("SELECT sha256_hash FROM malware_samples")
    rows = cursor.fetchall()

    conn.close()
    console.print(f"[blue]Loaded {len(rows)} known hashes from the database.[/blue]")
    return {row[0] for row in rows}


def fetch_samples_in_chunks(chunk_size=CHUNK_SIZE, total_count=TOTAL_SAMPLES):
    """
    Fetch malware samples in manageable chunks with rate-limiting and hash detection.
    :param chunk_size: Number of entries to fetch per request.
    :param total_count: Total number of samples to fetch.
    """
    console.print(f"[bold blue]Fetching malware samples in chunks of {chunk_size}...[/bold blue]")
    known_hashes = get_known_hashes()  # Load known hashes to skip duplicates
    total_fetched = 0

    for offset in range(0, total_count, chunk_size):
        console.print(f"[cyan]Fetching chunk starting at offset {offset}...[/cyan]")
        chunk = fetch_recent_samples(selector="200")  # Modify this to use offset if supported
        if not chunk:
            console.print("[yellow]No more samples fetched. Ending process early.[/yellow]")
            break
        
        # Debugging: Log fetched hashes
        console.print(f"[magenta]Fetched hashes: {[sample['sha256_hash'] for sample in chunk]}[/magenta]")
        
        # Filter out known hashes
        new_samples = [sample for sample in chunk if sample["sha256_hash"] not in known_hashes]
        console.print(f"[magenta]New samples after filtering: {[sample['sha256_hash'] for sample in new_samples]}[/magenta]")

        # Debugging: Verify filtering logic
        console.print(f"[yellow]Filtered out {len(chunk) - len(new_samples)} duplicates.[/yellow]")

        insert_samples_into_database(new_samples)
        total_fetched += len(new_samples)
        console.print(f"[green]Total new samples added: {total_fetched}[/green]")
        
        # Refresh known hashes periodically
        if offset % (chunk_size * 10) == 0:  # Refresh every 10 chunks
            known_hashes = get_known_hashes()
            console.print(f"[blue]Refreshed known hashes: {len(known_hashes)}[/blue]")

        # Apply rate-limiting delay
        console.print(f"[yellow]Rate-limiting: Waiting for {RATE_LIMIT_DELAY} seconds before next request...[/yellow]")
        time.sleep(RATE_LIMIT_DELAY)
    
    console.print(f"[bold green]Completed fetching malware samples! Total fetched: {total_fetched}[/bold green]")


def insert_samples_into_database(samples):
    """
    Insert malware samples into SQLite database.
    :param samples: List of malware sample dictionaries.
    """
    conn = sqlite3.connect(SAMPLES_DATABASE_FILE)
    cursor = conn.cursor()

    for sample in samples:
        try:
            # Check if the hash already exists
            cursor.execute("SELECT 1 FROM malware_samples WHERE sha256_hash = ?", (sample["sha256_hash"],))
            if cursor.fetchone():
                console.print(f"[yellow]Skipped duplicate hash: {sample['sha256_hash']}[/yellow]")
                continue

            # Insert only new samples
            cursor.execute("""
                INSERT INTO malware_samples (sha256_hash, metadata) VALUES (?, ?)
            """, (sample["sha256_hash"], json.dumps(sample)))
        except sqlite3.IntegrityError as e:
            # Retry logic for failed insertions
            for attempt in range(3):  # Retry up to 3 times
                try:
                    console.print(f"[red]Retrying after IntegrityError: {e} (Attempt {attempt + 1})[/red]")
                    time.sleep(1)  # Brief delay before retrying
                    cursor.execute("""
                        INSERT INTO malware_samples (sha256_hash, metadata) VALUES (?, ?)
                    """, (sample["sha256_hash"], json.dumps(sample)))
                    break  # Break out of retry loop on success
                except sqlite3.IntegrityError as e:
                    pass

    conn.commit()
    conn.close()
    console.print(f"[green]Inserted {len(samples)} samples into the database.[/green]")


def main():
    """
    Main workflow to fetch and store malware samples in chunks with rate-limiting and hash detection.
    """
    console.print("[bold blue]Starting Malware Sample Fetch...[/bold blue]")
    initialize_database()  # Ensure the database is ready
    fetch_samples_in_chunks()  # Fetch samples in chunks with rate-limiting and hash detection
    console.print("[bold green]Malware Samples Fetch Completed![/bold green]")


if __name__ == "__main__":
    main()